

\chapter{Overview}
\setcounter{page}{1}

\section{Introduction}
Implementing research pulse sequences on GE MR scanners requires EPIC programming, a time-consuming and error-prone task with a steep learning curve.
Moreover, pulse sequences need to be recompiled after each scanner software upgrade, which is sometimes problematic.

This user guide describes the ``toppe.e''\footnote{``The End Of Pulse Programming'', rearranged; pronounced ``top dot e''} pulse sequence for GE scanners, which allows the entire sequence to be specified with a set of external files created with a high-level software tool such as Matlab.
This makes it possible to play arbitrary sequences of RF pulses and gradient waveforms, which enables \textbf{rapid prototyping of sequences without the need for low-level EPIC programming}.
With\toppe, the task of pulse programming a GE scanner becomes one of creating the various external files that define the sequence.

\toppe~was developed as a research tool at the fMRI laboratory at University of Michigan, and has to date been used in several projects including stack-of-spirals imaging, Bloch-Siegert B1+ mapping, echo-shifted RF-spoiled imaging (PRESTO), steady-state imaging with 3D tailored RF excitation, and dual-echo steady-state (DESS) imaging.

We are currently making\toppe~compatible with {\bf Pulseq}, an open file format for compactly describing MR sequences.
See Chapter~\ref{ch:pulseq} for more information about using\toppe~as a GE ``interpreter module'' for Pulseq files.

This is the first 'beta' release of\toppe, and \textbf{your feedback} is most welcome. 
%Finally, if you are interesting in joining the development team, we'd love to hear from you.


\section{Required external files}
In addition to the {\tt toppe} and {\tt toppe.psd.o} executables, which only need to be compiled and installed once for each scanner software upgrade, the following files are needed to run a particular scan:

\subsection{ {\tt $\star$.wav} files}
\toppe~creates several unique ``cores'' (or modules), with each core/module associated with one .wav file (Fig.~\ref{fig:overview}).
For example, an RF excitation module may be defined by a file called {\tt tipdown.wav} that specifies the RF amplitude and phase waveforms (rho and theta) and all three gradients.
Similarly, a Cartesian (spin-warp) gradient-echo readout may be defined in a file {\tt readout.wav} that contains readout and phase-encode gradient waveforms.
Finally, a spoiler gradient can be defined in a file {\tt spoiler.wav}.
Each .wav file is unique up to a scaling factor, and typically only a few .wav files are needed.
Note that each .wav file gives rise to a separate {\tt createseq()} call in \toppe.

\subsection{\tt cores.txt}
The various $\star$.wav files needed to define a scan are listed in a small text file named {\tt cores.txt}, which simply contains a line for each .wav file specifying the file name, core duration, and whether it is an RF excitation module, readout module, or gradients-only module.
Values are tab-separated.
A {\tt cores.txt} file for our simple spin-warp imaging example may look like this:
\begin{lstlisting}
Total number of unique cores
3
wavfile_name	duration(us)	hasRF?	hasDAQ?
tipdown.wav	0	1	0
readout.wav	0	0	1
spoiler.wav	0	0	0
\end{lstlisting}
A duration of 0 means that the minimum core duration for that .wav file will be used.

\subsection{\tt scanloop.txt}
Finally, the complete MR scan loop is specified in {\tt scanloop.txt}, in which each line corresponds to a separate {\tt startseq()} call in\toppe.
A {\tt scanloop.txt} file for single-slice, RF-spoiled spin-warp imaging with 256 phase-encodes might begin like this:
\begin{lstlisting}
nt	maxslice	maxecho	maxview
768	1	0	768	
Core iarf iath iagx iagy iagz slice echo view dabon rot rfph recph textra freq
1	32766	32766	0	0	32766	0	0	0	0	0	0	0	0	0
2	0	0	32766	32766	-32638	1	0	1	1	0	0	0	0	0
3	0	0	0	0	32766	0	0	0	0	0	0	0	0	0
1	32766	32766	0	0	32766	0	0	0	0	0	21298	0	0	0
2	0	0	32766	32766	-32382	1	0	2	1	0	0	21298	0	0
3	0	0	0	0	32766	0	0	0	0	0	0	0	0	0
...
\end{lstlisting}
where nt is the total number of {\tt startseq()} calls (256 phase-encodes $\times$ 3 cores per TR), and \texttt{maxslice}, \texttt{maxecho}, and \texttt{maxview} correspond to \texttt{rhnslices}$-$1, \texttt{rhnecho}$-$1, and \texttt{rhnframes}, respecively, in\toppe.
\textbf{We do not recommend using the {\tt slice=0} and {\tt view=0} indeces (``slots'')}, hence the {\tt slice} and {\tt view} indeces both start at 1 in the above example.
Each row in {\tt scanloop.txt} specifies which core to play and with what RF and gradient amplitudes; where to store the data using $\tt loaddab()$ (i.e., which slice/echo/view); whether the core is used to acquire data; in-plane (kx,ky) rotation angle; the RF and acquisition phase; and a value 'textra' (in $\mu$s) by which the core duration is extended (see Ch.~\ref{ch:timing}).
Values are tab-separated.
For long scans, {\tt scanloop.txt} can contain many tens of thousands of lines.

%Figure~\ref{fig:overview} summarizes the ...

\mywrapfigure{overview}{R}{0.99}{
Overview of pulse sequence programming with\toppe.
The toppe/toppe.psd.o executables load the .wav files listed in {\tt cores.txt}, and play them out according to the instructions in {\tt scanloop.txt}.
Each .wav file contains the RF and gradient waveform shapes for one core.
A core is dedicated to either RF excitation, data acquisition, or gradients-only.
With this setup, arbitrary sequences of RF and gradient pulses can be played out, which enables rapid pulse sequence prototyping without the need for EPIC programming.
For detailing sequence timing information, see Ch.~\ref{ch:timing}.
}


% EOF
